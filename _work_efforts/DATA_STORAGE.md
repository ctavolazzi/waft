# Waft Framework: Data Storage Architecture

**Created**: 2026-01-04
**Purpose**: Document where and how waft stores data

---

## Overview

Waft uses a **file-based, decentralized storage model**. All data is stored directly in the project directory structure. There is **no database, no centralized storage, and no external data store**.

---

## Storage Locations

### 1. Primary Data Storage: `_pyrite/` Directory

**Location**: `{project_root}/_pyrite/`

This is the **"Memory"** layer of waft - the persistent structure that organizes project knowledge.

#### Structure
```
_pyrite/
├── active/          # Current work
│   └── .gitkeep    # Ensures folder is tracked by git
├── backlog/         # Future work
│   └── .gitkeep
└── standards/       # Project standards and protocols
    └── .gitkeep
```

#### How It Works
- **File-based**: Each folder contains regular files (markdown, text, etc.)
- **Git-tracked**: `.gitkeep` files ensure empty folders are tracked
- **User-managed**: Users place files directly in these folders
- **No schema**: No enforced structure - users organize as they see fit

#### Data Storage Format
- **Format**: Plain text files (typically `.md`, `.txt`, or any format)
- **Organization**: User-defined (no enforced structure)
- **Access**: Direct file system access
- **Version Control**: All files are git-tracked (if project is a git repo)

#### Example Files
```
_pyrite/
├── active/
│   ├── current-task.md
│   └── work-in-progress.txt
├── backlog/
│   ├── future-feature.md
│   └── ideas.md
└── standards/
    ├── coding-standards.md
    └── project-guidelines.md
```

#### Access Methods
- **CLI**: `waft info` shows file counts
- **API**: `waft serve` web dashboard displays files
- **Programmatic**: `MemoryManager.get_active_files()`, etc.
- **Direct**: Standard file system access

---

### 2. Project Configuration: `pyproject.toml`

**Location**: `{project_root}/pyproject.toml`

#### What's Stored
- Project metadata (name, version, description)
- Dependencies (managed by `uv`)
- Build configuration
- Project settings

#### How It Works
- **Format**: TOML (Tom's Obvious Minimal Language)
- **Managed by**: `uv` package manager (SubstrateManager)
- **Read/Write**: Through `uv` commands or direct file editing
- **Parsing**: Regex-based extraction (fallback) or TOML libraries

#### Example
```toml
[project]
name = "my-project"
version = "0.1.0"
dependencies = [
    "pytest>=7.0.0",
]
```

#### Access Methods
- **CLI**: `waft info` extracts name/version
- **Programmatic**: `SubstrateManager.get_project_info()`
- **Direct**: Standard file editing

---

### 3. Dependency Lock: `uv.lock`

**Location**: `{project_root}/uv.lock`

#### What's Stored
- Locked dependency versions
- Dependency tree
- Resolved package information

#### How It Works
- **Format**: TOML (generated by `uv`)
- **Managed by**: `uv sync` command
- **Read-only**: Users don't edit directly
- **Purpose**: Reproducible builds

#### Access Methods
- **CLI**: `waft verify` checks for existence
- **Programmatic**: `SubstrateManager.verify_lock()`
- **Direct**: File exists check only

---

### 4. Work Efforts (Framework Internal)

**Location**: `{project_root}/_work_efforts/`

**Note**: This is used by the waft framework itself for tracking work, not part of standard project structure.

#### Structure
```
_work_efforts/
├── devlog.md
├── WE-YYYYMMDD-xxxx_index.md
└── WE-YYYYMMDD-xxxx_work_effort_name/
    ├── tickets/
    │   └── TKT-xxxx-NNN_ticket_name.md
    └── WE-YYYYMMDD-xxxx_index.md
```

#### Format
- **Markdown files** with YAML frontmatter
- **Johnny Decimal** numbering system
- **Work effort tracking** for development

---

## Data Storage Characteristics

### 1. Decentralized
- **No central database**: Each project is self-contained
- **No server**: All data lives in the project directory
- **Portable**: Entire project (including data) can be moved/copied

### 2. File-Based
- **Plain files**: No binary formats or databases
- **Human-readable**: Markdown, TOML, text files
- **Version control friendly**: All data can be git-tracked

### 3. Git-Integrated
- **`.gitkeep` files**: Ensure empty directories are tracked
- **Standard git workflow**: All files follow normal git patterns
- **No special handling**: Works with any git setup

### 4. No Schema Enforcement
- **Flexible structure**: Users organize `_pyrite/` as needed
- **No validation**: Framework doesn't enforce file formats
- **User freedom**: Complete control over organization

---

## Data Access Patterns

### 1. Read Operations

#### Project Information
```python
from waft.core.substrate import SubstrateManager

substrate = SubstrateManager()
info = substrate.get_project_info(project_path)
# Returns: {"name": "...", "version": "..."}
```

#### Memory Structure
```python
from waft.core.memory import MemoryManager

memory = MemoryManager(project_path)
status = memory.verify_structure()
# Returns: {"valid": bool, "folders": {...}}

files = memory.get_active_files()
# Returns: [Path, Path, ...]
```

### 2. Write Operations

#### Creating Structure
```python
memory = MemoryManager(project_path)
memory.create_structure()
# Creates: _pyrite/active/, _pyrite/backlog/, _pyrite/standards/
```

#### Adding Files
- **Direct**: Users create files directly in `_pyrite/` folders
- **No API**: Framework doesn't provide file creation methods
- **User control**: Complete freedom in file organization

### 3. Query Operations

#### File Listing
```python
# Get all files in active
active_files = memory.get_active_files()

# Get all files in backlog
backlog_files = memory.get_backlog_files()

# Get all files in standards
standards_files = memory.get_standards_files()
```

#### Structure Validation
```python
status = memory.verify_structure()
if status["valid"]:
    # All required folders exist
    pass
```

---

## Data Persistence

### 1. Persistence Model
- **File system**: All data persists on disk
- **No in-memory cache**: Data is read fresh each time
- **No state management**: Stateless operations

### 2. Durability
- **Immediate**: Files written directly to disk
- **No transactions**: No rollback mechanism
- **Standard file I/O**: Uses Python's standard file operations

### 3. Backup/Recovery
- **Git**: Primary backup mechanism (if using git)
- **File system**: Standard backup tools work
- **No special tools**: Standard file operations

---

## Data Flow

### 1. Project Creation
```
waft new my_project
  ↓
1. uv init → pyproject.toml created
2. MemoryManager.create_structure() → _pyrite/ folders created
3. TemplateWriter.write_all() → Templates written
```

### 2. Data Access
```
User/CLI Request
  ↓
MemoryManager/SubstrateManager
  ↓
File System (read files)
  ↓
Return data
```

### 3. Data Modification
```
User Action (file creation/editing)
  ↓
Direct file system write
  ↓
Data persisted immediately
```

---

## Storage Limitations

### Current Limitations
1. **No indexing**: Files are not indexed or searchable
2. **No metadata**: No file metadata storage
3. **No relationships**: No linking between files
4. **No versioning**: Relies on git for versioning
5. **No query language**: No SQL or query interface
6. **No transactions**: No atomic operations

### Future Possibilities
- File indexing for search
- Metadata storage (JSON/YAML sidecars)
- Relationship tracking
- Built-in versioning
- Query interface
- Transaction support

---

## Comparison with Other Systems

### vs. Database Systems
- **Waft**: File-based, no database
- **Database**: Centralized, queryable, transactional
- **Trade-off**: Simplicity vs. power

### vs. Configuration Management
- **Waft**: Project-local, decentralized
- **Config Management**: Centralized, shared
- **Trade-off**: Portability vs. centralization

### vs. Document Stores
- **Waft**: Plain files, no schema
- **Document Store**: Structured, queryable
- **Trade-off**: Flexibility vs. structure

---

## Security Considerations

### 1. Access Control
- **File system permissions**: Relies on OS-level permissions
- **No built-in encryption**: Files stored in plain text
- **Git security**: Depends on git configuration

### 2. Data Privacy
- **Local storage**: All data stays in project directory
- **No cloud sync**: No automatic cloud storage
- **User control**: Complete control over data location

### 3. Backup Strategy
- **Git**: Primary backup (if using git)
- **File system**: Standard backup tools
- **No automatic backup**: User responsibility

---

## Performance Characteristics

### 1. Read Performance
- **Fast**: Direct file system access
- **No caching**: Reads from disk each time
- **Scalability**: Limited by file system performance

### 2. Write Performance
- **Immediate**: Direct file writes
- **No batching**: Each write is independent
- **No optimization**: Standard file I/O

### 3. Query Performance
- **Linear**: Must scan directories
- **No indexing**: No fast lookups
- **Small scale**: Designed for small to medium projects

---

## Data Migration

### 1. Project Migration
- **Copy directory**: Entire project is portable
- **No conversion**: Files work anywhere
- **Git-friendly**: Standard git operations

### 2. Version Migration
- **Backward compatible**: Old projects still work
- **Forward compatible**: New features don't break old data
- **No migration scripts**: Not needed (file-based)

---

## Summary

### Storage Model
- **Type**: File-based, decentralized
- **Location**: Project directory (`_pyrite/`, `pyproject.toml`, `uv.lock`)
- **Format**: Plain text (Markdown, TOML, text)
- **Access**: Direct file system + programmatic APIs

### Key Characteristics
- ✅ **Simple**: No database, no complexity
- ✅ **Portable**: Entire project is self-contained
- ✅ **Git-friendly**: All data can be version controlled
- ✅ **Human-readable**: Plain text files
- ✅ **Flexible**: No schema enforcement
- ⚠️ **Limited**: No indexing, querying, or advanced features

### Philosophy
Waft follows a **"files over databases"** philosophy:
- Data lives where the project lives
- No external dependencies
- Maximum portability
- Minimum complexity

---

**Last Updated**: 2026-01-04

